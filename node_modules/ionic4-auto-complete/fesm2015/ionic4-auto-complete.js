import { __decorate } from 'tslib';
import { EventEmitter, Input, Output, ViewChild, ElementRef, HostListener, Component, Pipe, Injectable, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { IonicModule } from '@ionic/angular';
import { Subject, from, Observable } from 'rxjs';
import { finalize } from 'rxjs/operators';

class AutoCompleteOptions {
    constructor() {
        this.animated = false;
        this.color = null;
        this.autocomplete = 'off';
        this.autocorrect = 'off';
        this.cancelButtonIcon = 'arrow-round-back';
        this.cancelButtonText = 'Cancelar';
        this.clearIcon = 'close-circle';
        this.clearInput = false;
        this.clearOnEdit = false;
        this.debounce = 250;
        this.mode = 'md';
        this.noItems = 'Ruta no disponible.';
        this.placeholder = 'Buscar';
        this.searchIcon = 'search';
        this.showCancelButton = false;
        this.spellcheck = 'off';
        this.type = 'search';
        this.value = '';
    }
}

class AutoCompleteStyles {
    constructor() {
        this.list = {};
        this.listItem = {};
        this.searchbar = {};
    }
}

var AutoCompleteComponent_1;
let AutoCompleteComponent = AutoCompleteComponent_1 = class AutoCompleteComponent {
    /**
     * Create a new instance
     */
    constructor() {
        this.alwaysShowList = false;
        this.autoFocusSuggestion = true;
        this.enableBrowserAutoComplete = false;
        this.clearInvalidInput = true;
        this.disabled = false;
        this.exclude = [];
        this.frontIcon = false;
        this.hideListOnSelection = true;
        this.location = 'auto';
        this.maxResults = 8;
        this.maxSelected = null;
        this.multi = false;
        this.name = '';
        this.removeButtonClasses = '';
        this.removeButtonColor = 'primary';
        this.removeButtonIcon = 'close-circle';
        this.removeButtonSlot = 'end';
        this.removeDuplicateSuggestions = true;
        this.selectOnTabOut = true;
        this.styles = new AutoCompleteStyles;
        this.useIonInput = false;
        this.autocompleteOptions = new AutoCompleteOptions();
        this.onTouchedCallback = false;
        this.onChangeCallback = false;
        this.hasFocus = false;
        this.isLoading = false;
        this.focusedOption = -1;
        this.showSuggestions = false;
        this.showListChanged = false;
        this.autoBlur = new EventEmitter();
        this.autoFocus = new EventEmitter();
        this.blur = new EventEmitter();
        this.focus = new EventEmitter();
        this.ionAutoInput = new EventEmitter();
        this.itemsChange = new EventEmitter();
        this.itemsCleared = new EventEmitter();
        this.itemsHidden = new EventEmitter();
        this.itemRemoved = new EventEmitter();
        this.itemSelected = new EventEmitter();
        this.itemsShown = new EventEmitter();
        this.modelChange = new EventEmitter();
        this.keyword = '';
        this.suggestions = [];
        this.autocompleteOptions = new AutoCompleteOptions();
        this.defaultOpts = new AutoCompleteOptions();
        this.selected = [];
    }
    get model() {
        let model = this.selected;
        if (!this.multi && typeof this.selected.length !== 'undefined') {
            if (this.selected.length === 0) {
                model = null;
            }
            else {
                model = this.selected[0];
            }
        }
        return model;
    }
    set model(selected) {
        if (typeof selected !== 'undefined' && selected !== null) {
            this.selected = selected;
            this.keyword = this.getLabel(selected);
        }
    }
    set options(options) {
        this.autocompleteOptions = new AutoCompleteOptions();
        const keys = Object.keys(this.autocompleteOptions);
        const keysLength = keys.length;
        for (let i = 0; i < keysLength; i++) {
            const key = keys[i];
            if (typeof options[key] !== 'undefined') {
                this.autocompleteOptions[key] = options[key];
            }
        }
    }
    set eager(eager) {
        if (eager) {
            this.getItems(null, false);
        }
    }
    get showList() {
        return this.showSuggestions;
    }
    set showList(value) {
        if (typeof value === 'undefined') {
            return;
        }
        if (this.showSuggestions === value) {
            return;
        }
        this.showSuggestions = value === true;
        this.showListChanged = true;
    }
    /**
     *
     */
    ngAfterViewChecked() {
        if (this.showListChanged) {
            this.showListChanged = false;
            this.showSuggestions ? this.itemsShown.emit() : this.itemsHidden.emit();
        }
    }
    ngDoCheck() {
        if (!this.hasFocus) {
            if (this.clearInvalidInput && (this.selected === null || this.multi)) {
                if (this.keyword !== '') {
                    this.keyword = '';
                }
                if (this.inputElem && this.inputElem.nativeElement) {
                    if (this.inputElem.nativeElement.children && this.inputElem.nativeElement.children.length !== 0) {
                        if (this.inputElem.nativeElement.children[0].children && this.inputElem.nativeElement.children[0].children.length !== 0) {
                            if (this.inputElem.nativeElement.children[0].children[0].value) {
                                this.inputElem.nativeElement.children[0].children[0].value = '';
                            }
                        }
                    }
                }
                if (this.searchbarElem && this.searchbarElem.nativeElement) {
                    if (this.searchbarElem.nativeElement.children && this.searchbarElem.nativeElement.children.length !== 0) {
                        if (this.searchbarElem.nativeElement.children[0].children) {
                            if (this.searchbarElem.nativeElement.children[0].children.length !== 0) {
                                if (this.searchbarElem.nativeElement.children[0].children[0].value) {
                                    this.searchbarElem.nativeElement.children[0].children[0].value = '';
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /**
     * Handle document click
     *
     * @param event
     *
     * @private
     */
    documentClickHandler(event) {
        if ((this.searchbarElem && this.searchbarElem.nativeElement && !this.searchbarElem.nativeElement.contains(event.target))
            ||
                (!this.inputElem && this.inputElem.nativeElement && this.inputElem.nativeElement.contains(event.target))) {
            this.hideItemList();
        }
    }
    /**
     * Get value from form
     *
     * @param selection
     *
     * @private
     */
    getFormValue(selection) {
        if (selection == null || typeof this.dataProvider === 'function') {
            return null;
        }
        let attr = this.dataProvider.formValueAttribute == null ?
            this.dataProvider.labelAttribute : this.dataProvider.formValueAttribute;
        if (typeof selection === 'object' && attr) {
            return selection[attr];
        }
        return selection;
    }
    /**
     * Get element's position on screen
     *
     * @param el
     *
     * @private
     */
    _getPosition(el) {
        let xPos = 0;
        let yPos = 0;
        while (el) {
            if (el.tagName === 'BODY') {
                const xScroll = el.scrollLeft || document.documentElement.scrollLeft;
                const yScroll = el.scrollTop || document.documentElement.scrollTop;
                xPos += (el.offsetLeft - xScroll + el.clientLeft);
                yPos += (el.offsetTop - yScroll + el.clientTop);
            }
            else {
                xPos += (el.offsetLeft - el.scrollLeft + el.clientLeft);
                yPos += (el.offsetTop - el.scrollTop + el.clientTop);
            }
            el = el.offsetParent;
        }
        return {
            x: xPos,
            y: yPos
        };
    }
    clickClear() {
        this.clearValue(true);
        this.itemsCleared.emit(true);
    }
    /**
     * Clear current input value
     *
     * @param hideItemList
     */
    clearValue(hideItemList = false) {
        this.keyword = '';
        this.selection = null;
        this.formValue = null;
        if (hideItemList) {
            this.hideItemList();
        }
        this.focusedOption = -1;
        return;
    }
    /**
     * Get items for auto-complete
     *
     * @param event
     * @param show
     */
    getItems(event, show) {
        this.isLoading = true;
        if (this.promise) {
            clearTimeout(this.promise);
        }
        this.promise = setTimeout(() => {
            if (event) {
                this.keyword = event.detail.target.value;
            }
            let result;
            if (this.showResultsFirst && this.keyword.trim() === '') {
                this.keyword = '';
            }
            if (typeof this.dataProvider === 'function') {
                result = this.dataProvider(this.keyword);
                this.setSuggestions(result, show);
                this.isLoading = false;
            }
            else {
                result = this.dataProvider.getResults(this.keyword);
                if (result instanceof Subject) {
                    result = result.asObservable();
                }
                else if (result instanceof Promise) {
                    result = from(result);
                }
                if (result instanceof Observable) {
                    result.pipe(finalize(() => {
                        this.isLoading = false;
                    })).subscribe((results) => {
                        this.setSuggestions(results, show);
                    }, (error) => console.error(error));
                }
                else {
                    this.setSuggestions(result, show);
                    this.isLoading = false;
                }
            }
            this.ionAutoInput.emit(this.keyword);
        }, this.autocompleteOptions.debounce);
    }
    /**
     * Get an item's label
     *
     * @param selection
     */
    getLabel(selection) {
        if (selection == null || typeof this.dataProvider === 'function') {
            return '';
        }
        let attr = this.dataProvider.formValueAttribute == null ?
            this.dataProvider.labelAttribute : this.dataProvider.formValueAttribute;
        let value = selection;
        if (this.dataProvider.getItemLabel) {
            value = this.dataProvider.getItemLabel(value);
        }
        if (!this.multi && typeof value !== 'undefined' && Object.prototype.toString.call(value) === '[object Array]') {
            if (value.length === 0) {
                return '';
            }
            else {
                value = value[0];
            }
        }
        if (typeof value === 'object' && attr) {
            return value[attr] || '';
        }
        return value || '';
    }
    /**
     * Get current selection
     */
    getSelection() {
        if (this.multi) {
            return this.selection;
        }
        else {
            return this.selected;
        }
    }
    /**
     * Get menu style
     */
    listStyles() {
        const listLocationStyles = this.listLocationStyles();
        return Object.assign({}, listLocationStyles, this.styles.list);
    }
    listLocationStyles() {
        let location = this.location;
        if (this.location === 'auto') {
            const elementY = this._getPosition(this.searchbarElem.nativeElement).y;
            const windowY = window.innerHeight;
            if (elementY > windowY - elementY) {
                location = 'top';
            }
            else {
                location = 'bottom';
            }
        }
        if (location === 'bottom') {
            return {};
        }
        else {
            return {
                'bottom': '37px'
            };
        }
    }
    /**
     * Get current input value
     */
    getValue() {
        return this.formValue;
    }
    /**
     * Handles tab key press.
     * If `selectOnTabOut` is `true`, will select currently focused item
     *
     * @param event
     */
    handleTabOut(event) {
        if (this.selectOnTabOut && this.suggestions.length !== 0) {
            if (this.focusedOption !== -1) {
                this.selectItem(this.suggestions[this.focusedOption]);
            }
            else {
                this.hideItemList();
            }
        }
        else {
            this.hideItemList();
        }
        this.onBlur(event);
    }
    /**
     * Handle tap
     *
     * @param event
     */
    handleTap(event) {
        if (this.showResultsFirst || this.keyword.length > 0) {
            this.getItems();
        }
    }
    /**
     * Handle tap when selecting an item
     *
     * @param $event
     * @param suggestion
     */
    handleSelectTap($event, suggestion) {
        if (typeof suggestion !== 'undefined') {
            this.selectItem(suggestion);
            if ($event.srcEvent) {
                if ($event.srcEvent.stopPropagation) {
                    $event.srcEvent.stopPropagation();
                }
                if ($event.srcEvent.preventDefault) {
                    $event.srcEvent.preventDefault();
                }
            }
            else if ($event.preventDefault) {
                $event.preventDefault();
            }
        }
        return false;
    }
    /**
     * Hide item list
     */
    hideItemList() {
        if (this.showSuggestions === false && this.alwaysShowList === false) {
            this.showListChanged = true;
        }
        this.showSuggestions = this.alwaysShowList;
        this.focusedOption = -1;
    }
    highlightItem(direction) {
        if (this.showSuggestions === false) {
            this.showItemList();
        }
        const max = this.suggestions.length - 1;
        if (direction < 0) {
            if (this.focusedOption === -1 || this.focusedOption === max) {
                this.focusedOption = 0;
            }
            else {
                this.focusedOption++;
            }
        }
        else if (direction > 0) {
            if (this.focusedOption === -1 || this.focusedOption === 0) {
                this.focusedOption = max;
            }
            else {
                this.focusedOption--;
            }
        }
    }
    /**
     * Fired when the input focused
     */
    onFocus(event) {
        this.hasFocus = true;
        this.getItems();
        event = this._reflectName(event);
        this.autoFocus.emit(event);
        this.focus.emit(event);
    }
    /**
     * Fired when the input focused
     */
    onBlur(event) {
        this.hasFocus = false;
        event = this._reflectName(event);
        this.autoBlur.emit(event);
        this.blur.emit(event);
    }
    _reflectName(event) {
        if (typeof event.srcElement.attributes['ng-reflect-name'] === 'object') {
            event.srcElement.name = event.srcElement.attributes['ng-reflect-name'].value;
        }
        return event;
    }
    /**
     * Register onChangeCallback
     *
     * @param fn
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * Register onTouchedCallback
     *
     * @param fn
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * Remove already selected suggestions
     *
     * @param suggestions
     */
    removeDuplicates(suggestions) {
        const selectedCount = this.selected ? this.selected.length : 0;
        const suggestionCount = suggestions.length;
        for (let i = 0; i < selectedCount; i++) {
            const selectedLabel = this.getLabel(this.selected[i]);
            for (let j = 0; j < suggestionCount; j++) {
                const suggestedLabel = this.getLabel(suggestions[j]);
                if (selectedLabel === suggestedLabel) {
                    suggestions.splice(j, 1);
                }
            }
        }
        return suggestions;
    }
    removeExcluded(suggestions) {
        const excludedCount = this.exclude.length;
        for (let i = 0; i < excludedCount; i++) {
            let excludeLabel = this.exclude[i];
            if (typeof excludeLabel === 'object') {
                excludeLabel = this.getLabel(excludeLabel);
            }
            const suggestionCount = suggestions.length;
            for (let j = 0; j < suggestionCount; j++) {
                const suggestedLabel = this.getLabel(suggestions[j]);
                if (excludeLabel === suggestedLabel) {
                    suggestions.splice(j, 1);
                    break;
                }
            }
        }
        return suggestions;
    }
    /**
     * Remove item from selected
     *
     * @param selection
     * @param notify?
     */
    removeItem(selection, notify) {
        const count = this.selected ? this.selected.length : 0;
        for (let i = 0; i < count; i++) {
            const item = this.selected[i];
            const selectedLabel = this.getLabel(selection);
            const itemLabel = this.getLabel(item);
            if (selectedLabel === itemLabel) {
                this.selected.splice(i, 1);
            }
        }
        notify = typeof notify === 'undefined' ? true : notify;
        if (notify) {
            this.itemRemoved.emit(selection);
            this.itemsChange.emit(this.selected);
        }
        this.modelChange.emit(this.selected);
    }
    /**
     * Select item from list
     *
     * @param selection
     **/
    selectItem(selection) {
        this.keyword = this.getLabel(selection);
        this.formValue = this.getFormValue(selection);
        this.hideItemList();
        this.updateModel(this.formValue);
        if (this.hideListOnSelection) {
            this.hideItemList();
        }
        if (this.multi) {
            if (this.maxSelected === null || this.selected.length <= this.maxSelected) {
                this.clearValue();
                this.selected.push(selection);
                this.itemsChange.emit(this.selected);
            }
            else {
                return;
            }
        }
        else {
            this.selection = selection;
            this.selected = [selection];
            this.itemsChange.emit(selection);
        }
        this.itemSelected.emit(selection);
        this.modelChange.emit(this.selected);
    }
    /**
     * Set focus of searchbar
     */
    setFocus() {
        if (this.useIonInput && this.inputElem) {
            this.inputElem.nativeElement.setFocus();
        }
        else if (this.searchbarElem) {
            this.searchbarElem.nativeElement.setFocus();
        }
    }
    /**
     * Set suggestions
     *
     * @param suggestions
     * @param show
     */
    setSuggestions(suggestions, show) {
        if (this.removeDuplicateSuggestions) {
            suggestions = this.removeDuplicates(suggestions);
            suggestions = this.removeExcluded(suggestions);
        }
        this.suggestions = suggestions;
        if (show || typeof show === 'undefined') {
            this.showItemList();
        }
        if (this.autoFocusSuggestion) {
            if (this.suggestions.length !== 0) {
                this.focusedOption = 0;
            }
        }
    }
    /**
     * Set current input value
     *
     * @param selection
     */
    setValue(selection) {
        this.formValue = this.getFormValue(selection);
        this.keyword = this.getLabel(selection);
        return;
    }
    /**
     * Show item list
     */
    showItemList() {
        if (this.showSuggestions === false) {
            this.showListChanged = true;
        }
        this.showSuggestions = true;
    }
    /**
     * Update the model
     */
    updateModel(enteredText) {
        if (enteredText !== this.formValue) {
            this.formValue = enteredText;
            if (!this.multi) {
                this.selected = null;
            }
        }
        if (this.onChangeCallback) {
            this.onChangeCallback(this.formValue);
        }
        this.modelChange.emit(this.selected);
    }
    /**
     * Write value
     *
     * @param value
     */
    writeValue(value) {
        if (value !== this.selection) {
            this.selection = value || null;
            this.formValue = this.getFormValue(this.selection);
            this.keyword = this.getLabel(this.selection);
        }
    }
};
__decorate([
    Input()
], AutoCompleteComponent.prototype, "alwaysShowList", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "autoFocusSuggestion", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "enableBrowserAutoComplete", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "clearInvalidInput", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "dataProvider", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "emptyTemplate", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "exclude", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "frontIcon", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "hideListOnSelection", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "keyword", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "location", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "maxResults", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "maxSelected", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "multi", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "name", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "removeButtonClasses", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "removeButtonColor", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "removeButtonIcon", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "removeButtonSlot", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "removeDuplicateSuggestions", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "selectionTemplate", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "selectOnTabOut", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "showResultsFirst", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "styles", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "template", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "useIonInput", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "model", null);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "options", null);
__decorate([
    Output()
], AutoCompleteComponent.prototype, "modelChange", void 0);
__decorate([
    Input()
], AutoCompleteComponent.prototype, "eager", null);
__decorate([
    Output()
], AutoCompleteComponent.prototype, "blur", void 0);
__decorate([
    Output()
], AutoCompleteComponent.prototype, "autoFocus", void 0);
__decorate([
    Output()
], AutoCompleteComponent.prototype, "autoBlur", void 0);
__decorate([
    Output()
], AutoCompleteComponent.prototype, "focus", void 0);
__decorate([
    Output()
], AutoCompleteComponent.prototype, "ionAutoInput", void 0);
__decorate([
    Output()
], AutoCompleteComponent.prototype, "itemsChange", void 0);
__decorate([
    Output()
], AutoCompleteComponent.prototype, "itemsCleared", void 0);
__decorate([
    Output()
], AutoCompleteComponent.prototype, "itemsHidden", void 0);
__decorate([
    Output()
], AutoCompleteComponent.prototype, "itemRemoved", void 0);
__decorate([
    Output()
], AutoCompleteComponent.prototype, "itemSelected", void 0);
__decorate([
    Output()
], AutoCompleteComponent.prototype, "itemsShown", void 0);
__decorate([
    ViewChild('searchbarElem', {
        read: ElementRef,
        static: false
    })
], AutoCompleteComponent.prototype, "searchbarElem", void 0);
__decorate([
    ViewChild('inputElem', {
        read: ElementRef,
        static: false
    })
], AutoCompleteComponent.prototype, "inputElem", void 0);
__decorate([
    HostListener('document:click', ['$event'])
], AutoCompleteComponent.prototype, "documentClickHandler", null);
AutoCompleteComponent = AutoCompleteComponent_1 = __decorate([
    Component({
        providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: AutoCompleteComponent_1,
                multi: true
            }
        ],
        selector: 'ion-auto-complete',
        template: "<ng-template #defaultSelection\n             let-attrs=\"attrs\">\n    <ion-chip class=\"{{ attrs.removeButtonClasses }}\"\n              [color]=\"attrs.removeButtonColor\"\n              [outline]=\"true\">\n        <ion-icon *ngIf=\"frontIcon\"\n                  [name]=\"frontIcon\"\n                  [slot]=\"'start'\"\n                  color=\"primary\"></ion-icon>\n\n        <ion-label>{{ attrs.label }}</ion-label>\n\n        <ion-icon *ngIf=\"attrs.removeButtonIcon\"\n                  [name]=\"attrs.removeButtonIcon\"\n                  [slot]=\"attrs.removeButtonSlot\"></ion-icon>\n    </ion-chip>\n</ng-template>\n\n<div *ngIf=\"multi\">\n    <div *ngFor=\"let item of selected\"\n         class=\"selected-items\"\n         (click)=\"removeItem(item)\">\n        <ng-template [ngTemplateOutlet]=\"selectionTemplate || defaultSelection\"\n                     [ngTemplateOutletContext]=\"{\n                            attrs: {\n                              data:                item,\n                              label:               getLabel(item),\n                              removeButtonClasses: removeButtonClasses,\n                              removeButtonColor:   removeButtonColor,\n                              removeButtonIcon:    removeButtonIcon,\n                              removeButtonSlot:    removeButtonSlot\n                            }\n                         }\"></ng-template>\n    </div>\n</div>\n\n<ion-input #inputElem\n           [autocomplete]=\"enableBrowserAutoComplete ? 'on' : 'off'\"\n           [name]=\"name\"\n           (ionInput)=\"getItems($event)\"\n           (tap)=\"handleTap($event)\"\n           [(ngModel)]=\"keyword\"\n           (ngModelChange)=\"updateModel($event)\"\n           [placeholder]=\"autocompleteOptions.placeholder == null ? defaultOpts.placeholder : autocompleteOptions.placeholder\"\n           [type]=\"autocompleteOptions.type == null ? defaultOpts.type : autocompleteOptions.type\"\n           [clearOnEdit]=\"autocompleteOptions.clearOnEdit == null ? defaultOpts.clearOnEdit : autocompleteOptions.clearOnEdit\"\n           [clearInput]=\"autocompleteOptions.clearInput == null ? defaultOpts.clearInput : autocompleteOptions.clearInput\"\n           [color]=\"autocompleteOptions.color == null ? null : autocompleteOptions.color\"\n           [mode]=\"autocompleteOptions.mode == null ? defaultOpts.mode : autocompleteOptions.mode\"\n           [disabled]=\"disabled || (this.maxSelected !== null && this.selected.length >= this.maxSelected)\"\n           [ngClass]=\"{ 'hidden': !useIonInput, 'loading': isLoading }\"\n           [ngStyle]=\"styles.searchbar\"\n           (keydown.tab)=\"handleTabOut($event)\"\n           (keydown.shift.tab)=\"hideItemList()\"\n           (keyup.arrowDown)=\"highlightItem(-1)\"\n           (keyup.arrowUp)=\"highlightItem(1)\"\n           (keyup.enter)=\"handleSelectTap($event, suggestions[focusedOption])\"\n           (keyup.escape)=\"hideItemList()\"\n           (ionFocus)=\"onFocus($event)\"\n           (ionBlur)=\"onBlur($event)\"></ion-input>\n\n<ion-searchbar #searchbarElem\n               [autocomplete]=\"enableBrowserAutoComplete ? 'on' : 'off'\"\n               [name]=\"name\"\n               [animated]=\"autocompleteOptions.animated == null ? defaultOpts.animated : autocompleteOptions.animated\"\n               (ionInput)=\"getItems($event)\"\n               (tap)=\"handleTap($event)\"\n               [(ngModel)]=\"keyword\"\n               (ngModelChange)=\"updateModel($event)\"\n               [cancelButtonIcon]=\"autocompleteOptions.cancelButtonIcon == null ? defaultOpts.cancelButtonIcon : autocompleteOptions.cancelButtonIcon\"\n               [cancelButtonText]=\"autocompleteOptions.cancelButtonText == null ? defaultOpts.cancelButtonText : autocompleteOptions.cancelButtonText\"\n               [clearIcon]=\"autocompleteOptions.clearIcon == null ? defaultOpts.clearIcon : autocompleteOptions.clearIcon\"\n               [color]=\"autocompleteOptions.color == null ? null : autocompleteOptions.color\"\n               [showCancelButton]=\"autocompleteOptions.showCancelButton == null ?\n                                        (defaultOpts.showCancelButton ? 'always' : 'never') :\n                                        (autocompleteOptions.showCancelButton ? 'always' : 'never')\"\n               [debounce]=\"autocompleteOptions.debounce == null ? defaultOpts.debounce : autocompleteOptions.debounce\"\n               [placeholder]=\"autocompleteOptions.placeholder == null ? defaultOpts.placeholder : autocompleteOptions.placeholder\"\n               [autocorrect]=\"autocompleteOptions.autocorrect == null ? defaultOpts.autocorrect : autocompleteOptions.autocorrect\"\n               [mode]=\"autocompleteOptions.mode == null ? defaultOpts.mode : autocompleteOptions.mode\"\n               [searchIcon]=\"autocompleteOptions.searchIcon == null ? defaultOpts.searchIcon : autocompleteOptions.searchIcon\"\n               [spellcheck]=\"autocompleteOptions.spellcheck == null ? defaultOpts.spellcheck : autocompleteOptions.spellcheck\"\n               [type]=\"autocompleteOptions.type == null ? defaultOpts.type : autocompleteOptions.type\"\n               [ngClass]=\"{ 'hidden': useIonInput, 'loading': isLoading, 'disabled': disabled || (this.maxSelected !== null && this.selected.length >= this.maxSelected) }\"\n               [ngStyle]=\"styles.searchbar\"\n               (keydown.tab)=\"handleTabOut($event)\"\n               (keydown.shift.tab)=\"hideItemList()\"\n               (keyup.arrowDown)=\"highlightItem(-1)\"\n               (keyup.arrowUp)=\"highlightItem(1)\"\n               (keyup.enter)=\"handleSelectTap($event, suggestions[focusedOption])\"\n               (keyup.escape)=\"hideItemList()\"\n               (ionClear)=\"clickClear()\"\n               (ionFocus)=\"onFocus($event)\"\n               (ionBlur)=\"onBlur($event)\"></ion-searchbar>\n\n<ng-template #defaultTemplate\n             let-attrs=\"attrs\">\n    <span [innerHTML]='attrs.label | boldprefix:attrs.keyword'></span>\n</ng-template>\n\n<ng-template #defaultEmptyTemplate\n             let-attrs=\"attrs\"\n             class=\"ion-text-center\">\n    {{ autocompleteOptions.noItems }}\n</ng-template>\n\n<ul *ngIf=\"!(disabled || (this.maxSelected !== null && this.selected.length >= this.maxSelected)) && suggestions.length > 0 && showSuggestions\"\n    [ngStyle]=\"listStyles()\">\n    <li *ngFor=\"let suggestion of suggestions| slice:0:maxResults; let index = index\"\n        [ngClass]=\"{ 'focus': focusedOption === index }\"\n        [ngStyle]=\"styles.listItem\"\n        (mouseenter)=\"focusedOption = index\"\n        (click)=\"handleSelectTap($event, suggestion)\"\n        (tap)=\"handleSelectTap($event, suggestion)\">\n        <ng-template [ngTemplateOutlet]=\"template || defaultTemplate\"\n                     [ngTemplateOutletContext]=\"{\n                        attrs:{\n                          data:               suggestion,\n                          label:              getLabel(suggestion),\n                          keyword:            keyword,\n                          formValue:          getFormValue(suggestion),\n                          labelAttribute:     getLabel(suggestion),\n                          formValueAttribute: getFormValue(suggestion)\n                        }\n                     }\"></ng-template>\n    </li>\n</ul>\n\n<ul *ngIf=\"suggestions.length === 0 && showSuggestions\"\n    [ngStyle]=\"listStyles()\">\n    <li [ngStyle]=\"styles.listItem\">\n        <ng-template [ngTemplateOutlet]=\"emptyTemplate || defaultEmptyTemplate\"\n                     [ngTemplateOutletContext]=\"{\n                        attrs:{\n                          keyword: keyword\n                        }\n                     }\"></ng-template>\n    </li>\n</ul>\n",
        styles: ["ion-auto-complete{overflow:hidden!important;width:90vw;display:inline-block}ion-auto-complete ion-searchbar{padding:1px!important}ion-auto-complete .disabled input.searchbar-input{pointer-events:none;cursor:default}ion-auto-complete ul{position:absolute;width:90vw;margin-top:0;background:#fff;list-style-type:none;padding:0;left:16px;z-index:999;box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 3px 1px -2px rgba(0,0,0,.2),0 1px 5px 0 rgba(0,0,0,.12)}ion-auto-complete ul li{padding:15px;border-bottom:1px solid #c1c1c1}ion-auto-complete ul ion-auto-complete-item{height:40px;width:100%}ion-auto-complete ul li:last-child{border:none}ion-auto-complete ul li.focus,ion-auto-complete ul li:focus{cursor:pointer;background:#f1f1f1}ion-auto-complete .hidden{display:none}ion-auto-complete .loading input.searchbar-input{background:url(/assets/loading.gif) right 4px center/25px 25px no-repeat #fff}ion-auto-complete .searchbar-clear-button.sc-ion-searchbar-md{right:34px}ion-auto-complete .selected-items{float:left}"]
    })
], AutoCompleteComponent);

/**
 * Bolds the beginning of the matching string in the item
 */
let BoldPrefix = class BoldPrefix {
    transform(value, keyword) {
        if (!keyword) {
            return value;
        }
        let escaped_keyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        return value.replace(new RegExp(escaped_keyword, 'gi'), function (str) {
            return str.bold();
        });
    }
};
BoldPrefix = __decorate([
    Pipe({
        name: 'boldprefix'
    }),
    Injectable()
], BoldPrefix);

var AutoCompleteModule_1;
let AutoCompleteModule = AutoCompleteModule_1 = class AutoCompleteModule {
    static forRoot() {
        return {
            ngModule: AutoCompleteModule_1,
            providers: []
        };
    }
};
AutoCompleteModule = AutoCompleteModule_1 = __decorate([
    NgModule({
        declarations: [
            AutoCompleteComponent,
            BoldPrefix
        ],
        exports: [
            AutoCompleteComponent,
            BoldPrefix
        ],
        imports: [
            CommonModule,
            FormsModule,
            IonicModule
        ]
    })
], AutoCompleteModule);

/**
 * Generated bundle index. Do not edit.
 */

export { AutoCompleteComponent, AutoCompleteModule, AutoCompleteOptions, BoldPrefix };
//# sourceMappingURL=ionic4-auto-complete.js.map
